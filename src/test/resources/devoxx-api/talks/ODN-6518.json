{
  "trackId" : "java",
  "talkType" : "University",
  "track" : "Java, JVM, Javas SE/EE",
  "summaryAsHtml" : "<p>Introduite en Java 8, l'API Collector vit dans l'ombre de l'API Stream, ce qui est logique puisqu'un collecteur doit se connecter à un stream pour fonctionner. Le JDK est organisé de sorte que l'on utilise surtout les collectors sur étagère : groupingBy, counting et quelques autres. Ces deux éléments masquent non seulement le modèle de traitement de données des collectors, mais aussi sa puissance et ses performances.</p>\n<p>On parlera donc collectors : ceux qui existent car il faut les connaître, ceux que l'on peut créer, ceux dont on se doute que l'on peut les créer une fois que l'on comprend un peu les choses, et les autres, tant les possibilités offertes par cette API sont illimitées.</p>\n<p>On insistera sur le concept de downstream collector, central dans cette API.</p>\n<p>On montrera comment écrire des traitements entiers sous forme de collectors, de façon à pouvoir les passer en paramètre d'autres traitements.</p>\n<p>On ne laissera de côté ni la lisibilité du code ni ses performances, vue l'importance de ces deux points dans ce type de traitement.</p>\n<p>Des slides, mais aussi beaucoup d'exemples réels en live coding.</p>\n",
  "id" : "ODN-6518",
  "speakers" : [
    {
      "link" : {
        "href" : "http://cfp.devoxx.fr/api/conferences/DevoxxFR2017/speakers/70365c89d2a734da0d24d091f7ec0af77ba90701",
        "rel" : "http://cfp.devoxx.fr/api/profile/speaker",
        "title" : "José Paumard"
      },
      "name" : "José Paumard"
    }
  ],
  "title" : "L'API Collector dans tous ses états",
  "lang" : "fr",
  "summary" : "Introduite en Java 8, l'API Collector vit dans l'ombre de l'API Stream, ce qui est logique puisqu'un collecteur doit se connecter à un stream pour fonctionner. Le JDK est organisé de sorte que l'on utilise surtout les collectors sur étagère : groupingBy, counting et quelques autres. Ces deux éléments masquent non seulement le modèle de traitement de données des collectors, mais aussi sa puissance et ses performances. \r\n\r\nOn parlera donc collectors : ceux qui existent car il faut les connaître, ceux que l'on peut créer, ceux dont on se doute que l'on peut les créer une fois que l'on comprend un peu les choses, et les autres, tant les possibilités offertes par cette API sont illimitées. \r\n\r\nOn insistera sur le concept de downstream collector, central dans cette API. \r\n\r\nOn montrera comment écrire des traitements entiers sous forme de collectors, de façon à pouvoir les passer en paramètre d'autres traitements. \r\n\r\nOn ne laissera de côté ni la lisibilité du code ni ses performances, vue l'importance de ces deux points dans ce type de traitement. \r\n\r\nDes slides, mais aussi beaucoup d'exemples réels en live coding. "
}